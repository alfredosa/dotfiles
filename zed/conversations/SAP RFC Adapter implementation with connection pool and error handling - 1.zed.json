{"id":"ce4a937e-a0d6-4b77-ace0-f1f069141faa","zed":"context","version":"0.4.0","text":"\n\n\n\nmember-customer-directory/src/internal/pkg/datadog\n```go member-customer-directory/src/internal/pkg/datadog/datadog.go\n//go:build !coverage\n\npackage datadog\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/coopnorge/go-datadog-lib/v2/tracing\"\n\t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n)\n\n// ExecuteCallWithTracer wraps `executeCall` to Datadog span if it's possible at the moment\n// `fullOperationName` what will be called and from where, example: MySQL, Oracle etc.\n// `requestedResource` what was requested initially => GetUser.\nfunc ExecuteCallWithTracer[T any](\n\tctx context.Context,\n\texecuteCall func() (T, error),\n\tcalledSource,\n\trequestedResource string,\n) (T, error) {\n\ttraceSpan := tracing.CreateChildSpan(ctx, fmt.Sprintf(\"%s.%s\", calledSource, requestedResource), requestedResource)\n\tresp, err := executeCall()\n\ttraceSpan.Finish(tracer.WithError(err))\n\n\treturn resp, err\n}\n```\n\n```go member-customer-directory/src/internal/pkg/adapter/sap/sap.go\npackage sap\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/coopnorge/member-customer-directory/src/internal/app/infrastructure\"\n\t\"github.com/coopnorge/member-customer-directory/src/internal/pkg/datadog\"\n\t\"github.com/coopnorge/member-lib/creational/pool\"\n\t\"github.com/coopnorge/member-lib/stringconv\"\n)\n\n// RFCAdapter that handles the communication with SAP CRM System.\ntype RFCAdapter struct {\n\tlogger        LoggerAdapter\n\tconnectorPool *pool.ResourcePoolManager[Connector]\n\n\tisTestMode           bool\n\tconnectionLastActive time.Time\n\tconnectionTimeToLive time.Duration\n\tctx                  context.Context\n\tctxCancel            context.CancelFunc\n\tmu                   sync.Mutex\n\terrorProtection      *ErrorProtection\n}\n\n// NewSAPAdapter that will allow to send RFC request to SAP.\n// Constructor building parameters that will be passed to RFC_CONNECTION_HANDLE.\n// Additional doc reference \"https://help.sap.com/docs/SAP_NETWEAVER_750/753088fc00704d0a80e7fbd6803c8adb/48a88d7f5134307de10000000a42189b.html?version=7.5.9\".\nfunc NewSAPAdapter(cfg *ConnectionConfiguration, logAdapter LoggerAdapter) *RFCAdapter {\n\tctx, cancel := context.WithCancel(context.Background())\n\trfc := &RFCAdapter{\n\t\tlogger:               logAdapter,\n\t\tconnectionTimeToLive: defaultConnectionIDLETimeout,\n\t\tconnectionLastActive: time.Now(),\n\t\tctx:                  ctx,\n\t\tctxCancel:            cancel,\n\t}\n\n\tduration, parseTimeErr := time.ParseDuration(cfg.ConnectionTimeToLive)\n\tif parseTimeErr == nil && duration > 0 {\n\t\trfc.connectionTimeToLive = duration\n\t}\n\n\tmaxRFCMessagesPerConnections := sapMaxDefaultMessagesPerConnection\n\tmaxRFCConnections := sapMaxDefaultConnections\n\n\tif idleTimeout, convErr := stringconv.ToWholeNumber[uint16](cfg.ConnectionIDLETimeout); convErr == nil {\n\t\trfc.connectionTimeToLive = time.Duration(idleTimeout) * time.Minute\n\t}\n\tif maxConnections, convErr := stringconv.ToWholeNumber[uint8](cfg.MaxConnections); convErr == nil {\n\t\tmaxRFCConnections = maxConnections\n\t}\n\tif maxMsgPerConn, convErr := stringconv.ToWholeNumber[uint8](cfg.MaxMessagesPerConnection); convErr == nil {\n\t\tmaxRFCMessagesPerConnections = maxMsgPerConn\n\t}\n\n\trfc.connectorPool = pool.NewResourcePoolManager[Connector](maxRFCConnections, maxRFCMessagesPerConnections, &ConnectorFactory{cfg: cfg, logger: logAdapter})\n\trfc.connectorPool.SetRetryOnResourceDelay(time.Millisecond)\n\n\t// Default values are set if not provided or set to 0.\n\trfc.errorProtection = NewErrorProtection(0, 0)\n\n\treturn rfc\n}\n\n// Name of concrete AdapterInfrastructure implementation.\nfunc (rfc *RFCAdapter) Name() (msg string) {\n\treturn sapAdapterName\n}\n\n// Connect adapter to depended on system.\nfunc (rfc *RFCAdapter) Connect(ctx context.Context) error {\n\tif rfc.isTestMode { // Will never happen in production\n\t\treturn errors.New(\"adapter is enabled in testing mode\")\n\t}\n\n\tresourceErr := rfc.connectorPool.AcquireAndReleaseResource(ctx, func(connector *Connector) error {\n\t\treturn connector.Connect()\n\t})\n\tif resourceErr != nil {\n\t\treturn fmt.Errorf(\"unable to open RFC connection to SAP, error: %w\", resourceErr)\n\t}\n\n\trfc.updateLastActiveTime()\n\n\treturn nil\n}\n\n// Disconnect adapter from system and free resources.\nfunc (rfc *RFCAdapter) Disconnect(ctx context.Context) error {\n\tresourceErr := rfc.connectorPool.AcquireAndReleaseResource(ctx, func(connector *Connector) error {\n\t\treturn connector.Disconnect()\n\t})\n\tif resourceErr != nil {\n\t\treturn fmt.Errorf(\"unable to close RFC connection to SAP, error: %w\", resourceErr)\n\t}\n\n\treturn nil\n}\n\n// HealthCheck reports status message that related to component.\nfunc (rfc *RFCAdapter) HealthCheck(ctx context.Context) (report string, reportErr error) {\n\trfc.updateLastActiveTime()\n\treport = infrastructure.HealthStatusBad\n\tif ctx.Err() != nil {\n\t\treturn report, ctx.Err()\n\t}\n\n\tconnector, connectorErr := rfc.connectorPool.AcquireResource(ctx, true)\n\tif connectorErr != nil {\n\t\treportErr = connectorErr\n\t\treturn\n\t}\n\n\t_, pingErr := connector.CallRFC(ctx, sapFunctionPing, make(map[string]interface{}))\n\tif errors.Is(pingErr, ErrConnectorConnectionIssues) {\n\t\trfc.connectorPool.DetachResource(connector)\n\t\tctx = rfc.handleRetryRFCCallWithBackoff(ctx, sapFunctionPing, pingErr)\n\t\treturn rfc.HealthCheck(ctx)\n\t} else if pingErr != nil {\n\t\treportErr = pingErr\n\t\trfc.connectorPool.ReleaseResource(connector)\n\t\treturn\n\t}\n\n\trfc.connectorPool.ReleaseResource(connector)\n\treport = infrastructure.HealthStatusOk\n\n\treturn\n}\n\n// FetchCustomerProfile as basic information.\nfunc (rfc *RFCAdapter) FetchCustomerProfile(ctx context.Context, coopID string) (*Customer, error) {\n\tcallResult, callErr := rfc.fetchByCoopID(ctx, coopID, sapFunctionGcpBpPull)\n\tif callErr != nil {\n\t\treturn nil, callErr\n\t}\n\n\tparsedResponse, parserError := ParseResponseToModel[PartnerProfile](callResult)\n\tif parserError != nil {\n\t\tif strings.Contains(parserError.Error(), sapErrorMessagePartnerNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\trfc.logger.Errorf(ctx, \"%s - %s, error: %s\", sapAdapterName, sapFunctionGcpBpPull, parserError.Error())\n\t\treturn nil, parserError\n\t} else if len(parsedResponse) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &parsedResponse[0].Customer, nil\n}\n\n// FetchCustomerMembershipProfile with detailed member information.\nfunc (rfc *RFCAdapter) FetchCustomerMembershipProfile(ctx context.Context, coopID string) ([]MembershipProfile, error) {\n\tcallResult, callErr := rfc.fetchByCoopID(ctx, coopID, sapFunctionPullMembership)\n\tif callErr != nil {\n\t\treturn nil, callErr\n\t}\n\n\tparsedResponse, parserError := ParseResponseToModel[MembershipProfile](callResult)\n\tif parserError != nil {\n\t\tif strings.Contains(parserError.Error(), sapErrorMessageMembershipNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\trfc.logger.Errorf(ctx, \"%s - %s, error: %s\", sapAdapterName, sapFunctionPullMembership, parserError.Error())\n\t\treturn nil, parserError\n\t} else if len(parsedResponse) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn parsedResponse, nil\n}\n\n// FetchCustomerMemberCards with related member information.\nfunc (rfc *RFCAdapter) FetchCustomerMemberCards(ctx context.Context, coopID string) ([]MemberCardProfile, error) {\n\tcallResult, callErr := rfc.fetchByCoopID(ctx, coopID, sapFunctionPullMemberCards)\n\tif callErr != nil {\n\t\treturn nil, callErr\n\t}\n\n\tparsedResponse, parserError := ParseResponseToModel[MemberCardProfile](callResult)\n\tif parserError != nil {\n\t\tif strings.Contains(parserError.Error(), sapErrorMessageMemberCardsNotFound) {\n\t\t\treturn nil, nil\n\t\t}\n\t\trfc.logger.Errorf(ctx, \"%s - %s, error: %s\", sapAdapterName, sapFunctionPullMemberCards, parserError.Error())\n\t\treturn nil, parserError\n\t} else if len(parsedResponse) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn parsedResponse, nil\n}\n\n// ParseCustomerSocialSecurityNumber decoding SSN to get base information about person.\nfunc (rfc *RFCAdapter) ParseCustomerSocialSecurityNumber(ctx context.Context, ssn string) (*ProfileSSNDetails, error) {\n\tif ctx.Err() != nil {\n\t\treturn nil, ctx.Err()\n\t} else if len(ssn) != 11 { // NOTE: https://www.skatteetaten.no/en/person/national-registry/identitetsnummer/fodselsnummer/\n\t\treturn nil, errors.New(\"invalid argument, SSN or NIN is too short\")\n\t}\n\n\trfc.updateLastActiveTime()\n\n\tconnector, connectorErr := rfc.connectorPool.AcquireResource(ctx, true)\n\tif connectorErr != nil {\n\t\treturn nil, connectorErr\n\t}\n\n\tcallResult, callResultErr := connector.CallRFC(ctx, sapFunctionParseSSN, NewParamsFactory().WithSSN(ssn).Make())\n\tif errors.Is(callResultErr, ErrConnectorConnectionIssues) {\n\t\trfc.connectorPool.DetachResource(connector)\n\t\tctx = rfc.handleRetryRFCCallWithBackoff(ctx, sapFunctionParseSSN, callResultErr)\n\t\treturn rfc.ParseCustomerSocialSecurityNumber(ctx, ssn)\n\t}\n\n\trfc.connectorPool.ReleaseResource(connector)\n\n\tparsedResponse, parserError := ParseResponseToModel[ProfileSSNDetails](callResult)\n\tif parserError != nil {\n\t\trfc.logger.Errorf(ctx, \"%s - %s, error: %s\", sapAdapterName, sapFunctionParseSSN, parserError.Error())\n\t\treturn nil, parserError\n\t}\n\n\tif len(parsedResponse) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn &parsedResponse[0], nil\n}\n\n// UpdateCustomerPhoneNumber in given customer profile.\nfunc (rfc *RFCAdapter) UpdateCustomerPhoneNumber(ctx context.Context, coopID string, phone *Phone) error {\n\trfc.updateLastActiveTime()\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tconnector, connectorErr := rfc.connectorPool.AcquireResource(ctx, true)\n\tif connectorErr != nil {\n\t\treturn connectorErr\n\t}\n\n\tdefer rfc.connectorPool.ReleaseResource(connector)\n\n\tcallParams := NewParamsFactory().WithCoopID(coopID).UpdateCommunicationPhone(phone).Make()\n\tcallResult, callResultErr := connector.CallRFC(ctx, sapFunctionProfileUpdatePhone, callParams)\n\tif callResultErr != nil {\n\t\treturn callResultErr\n\t}\n\n\tpayload, payloadErr := extractRFCReturnMessages(callResult)\n\tif payloadErr != nil {\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Phone=%s, error: %w\", coopID, phone.Number, payloadErr)\n\t}\n\tif len(payload) != 0 { // NOTE: SAP RFC under key `defaultRFCPayloadMessage` can return list of errors in this case\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Phone=%s, SAP RFC segmentation fault messages: %v\", coopID, phone.Number, payload)\n\t}\n\n\treturn nil\n}\n\n// UpdateCustomerEmail related to the customer.\nfunc (rfc *RFCAdapter) UpdateCustomerEmail(ctx context.Context, coopID, email string) error {\n\trfc.updateLastActiveTime()\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tconnector, connErr := rfc.connectorPool.AcquireResource(ctx, true)\n\tif connErr != nil {\n\t\treturn connErr\n\t}\n\n\tdefer rfc.connectorPool.ReleaseResource(connector)\n\n\tcallparams := NewParamsFactory().WithCoopID(coopID).UpdateCommunicationEmail(email).Make()\n\tcallResult, callResultErr := connector.CallRFC(ctx, sapFunctionUpdateCustomerEmail, callparams)\n\tif callResultErr != nil {\n\t\treturn callResultErr\n\t}\n\n\tpayload, payloadErr := extractRFCReturnMessages(callResult)\n\tif payloadErr != nil {\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Email=%s, error: %w\", coopID, email, payloadErr)\n\t}\n\tif len(payload) != 0 {\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Email=%s, SAP RFC error message: %v\", coopID, email, payload)\n\t}\n\n\treturn nil\n}\n\n// UpdateCustomerAddress related to the customer.\nfunc (rfc *RFCAdapter) UpdateCustomerAddress(ctx context.Context, coopID string, address *StreetAddress) error {\n\trfc.updateLastActiveTime()\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tconnector, connectorErr := rfc.connectorPool.AcquireResource(ctx, true)\n\tif connectorErr != nil {\n\t\treturn connectorErr\n\t}\n\n\tdefer rfc.connectorPool.ReleaseResource(connector)\n\n\tcallParams := NewParamsFactory().WithCoopID(coopID).UpdateCommunicationAddress(address).Make()\n\tcallResult, callResultErr := connector.CallRFC(ctx, sapFunctionProfileUpdateAddress, callParams)\n\tif callResultErr != nil {\n\t\treturn callResultErr\n\t}\n\tpayload, payloadErr := extractRFCReturnMessages(callResult)\n\tif payloadErr != nil {\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Address=%s, error: %w\", coopID, address, payloadErr)\n\t}\n\tif len(payload) != 0 {\n\t\treturn fmt.Errorf(\"failed to update profile CoopID=%s contact Address=%s, SAP RFC error message: %v\", coopID, address, payload)\n\t}\n\treturn nil\n}\n\n// fetchByCoopID from SAP CRM by calling RFC.\n// R - Result that will be returned after RFC call and parser.\nfunc (rfc *RFCAdapter) fetchByCoopID(ctx context.Context, coopID string, rfcName RfcName) (ResponseObject, error) {\n\trfc.updateLastActiveTime()\n\tif ctx.Err() != nil {\n\t\treturn nil, ctx.Err()\n\t}\n\n\tconnector, connectorErr := datadog.ExecuteCallWithTracer[*Connector](ctx, rfc.connectorPool.AcquireResource(ctx, true), \"AcquireResource\", rfcName)\n\tif connectorErr != nil {\n\t\treturn nil, connectorErr\n\t}\n\n\tresponse, responseErr := connector.CallRFC(ctx, rfcName, NewParamsFactory().WithCoopIDLegacy(coopID).Make())\n\tif errors.Is(responseErr, ErrConnectorConnectionIssues) {\n\t\trfc.connectorPool.DetachResource(connector)\n\t\tctx = rfc.handleRetryRFCCallWithBackoff(ctx, rfcName, responseErr)\n\t\treturn rfc.fetchByCoopID(ctx, coopID, rfcName)\n\t}\n\n\trfc.connectorPool.ReleaseResource(connector)\n\n\treturn response, responseErr\n}\n\n// monitorConnector track activity of RFC Connector.\nfunc (rfc *RFCAdapter) monitorConnector() error {\n\tticker := time.NewTicker(rfc.connectionTimeToLive)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\trfc.mu.Lock()\n\t\t\tconnector, connectorErr := rfc.connectorPool.AcquireResource(rfc.ctx, false)\n\t\t\tif connectorErr != nil {\n\t\t\t\trfc.logger.Warnf(\n\t\t\t\t\trfc.ctx,\n\t\t\t\t\t\"%s - unable to acquire resource - SAP RFC Connector to perform connection check, error: %s\",\n\t\t\t\t\tsapAdapterName,\n\t\t\t\t\tconnectorErr.Error(),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif connector == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\trfc.detachAndReleaseConnector(connector)\n\n\t\t\trfc.mu.Unlock()\n\t\tcase <-rfc.ctx.Done():\n\t\t\terr := rfc.errorProtection.Check()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn errors.New(\"monitoring context was cancelled\")\n\t\t}\n\t}\n}\n\nfunc (rfc *RFCAdapter) detachAndReleaseConnector(connector *Connector) {\n\tif (time.Since(rfc.connectionLastActive) >= rfc.connectionTimeToLive) && connector.IsConnected() {\n\t\tif dcErr := connector.Disconnect(); dcErr != nil {\n\t\t\trfc.logger.Warnf(rfc.ctx, \"%s - Disconnect due to inactivity failed, error: %s\", sapAdapterName, dcErr.Error())\n\t\t}\n\n\t\trfc.connectorPool.DetachResource(connector)\n\t} else {\n\t\trfc.connectorPool.ReleaseResource(connector)\n\t}\n}\n\n// StartMonitoring will track activity of RFC Connector.\nfunc (rfc *RFCAdapter) StartMonitoring() error {\n\tgo rfc.errorProtection.StartErrorProtectionCleanup(rfc.ctx)\n\treturn rfc.monitorConnector()\n}\n\n// StopMonitoring gracefully stops the StartConnectionMonitoring process of RFC Connector.\nfunc (rfc *RFCAdapter) StopMonitoring() {\n\trfc.ctxCancel()\n}\n\n// GracefulShutdown cleans all allocated resources in adapter.\nfunc (rfc *RFCAdapter) GracefulShutdown(ctx context.Context) error {\n\treturn rfc.connectorPool.CleanUpManagedResources(ctx)\n}\n\nfunc (rfc *RFCAdapter) updateLastActiveTime() {\n\trfc.mu.Lock()\n\tdefer rfc.mu.Unlock()\n\n\trfc.connectionLastActive = time.Now()\n}\n\n// handleRetryRFCCallWithBackoff will prevent spam and makes gracefully back off of retry.\nfunc (rfc *RFCAdapter) handleRetryRFCCallWithBackoff(ctx context.Context, rfcName RfcName, failReason error) (ctxWithBackoff context.Context) {\n\tif ctx.Err() != nil {\n\t\treturn ctx\n\t}\n\n\tbackOff, isBackOffSet := ctx.Value(rfcCallBackoffContextKey).(time.Duration)\n\tif !isBackOffSet {\n\t\tbackOff = defaultInitialRetryBackoff\n\t}\n\n\trfc.logger.Warnf(\n\t\tctx,\n\t\t\"%s faield call RFC (%s) with error (%s) retrying again with backoff time (%s)\",\n\t\tsapAdapterName,\n\t\trfcName,\n\t\tfailReason,\n\t\tbackOff.String(),\n\t)\n\n\t// handle SAP connection error as harmful\n\trfc.handleSAPConnectionErrorAsHarmful(ctx, rfcName)\n\n\ttime.Sleep(backOff)\n\n\treturn context.WithValue(ctx, rfcCallBackoffContextKey, backOff<<1)\n}\n\nfunc (rfc *RFCAdapter) handleSAPConnectionErrorAsHarmful(ctx context.Context, rfcName RfcName) {\n\tif ctx.Err() != nil {\n\t\treturn\n\t}\n\n\trfc.errorProtection.harmfoulErrors.Add(1)\n\n\tif int(rfc.errorProtection.harmfoulErrors.Load()) > rfc.errorProtection.maxHarmfulErrors {\n\t\tif err := rfc.GracefulShutdown(ctx); err != nil {\n\t\t\trfc.logger.Warnf(ctx, \"%s - %s - %s\", sapAdapterName, rfcName, err)\n\t\t}\n\n\t\trfc.logger.Errorf(\n\t\t\tctx,\n\t\t\t\"%s - %s - %s\",\n\t\t\tsapAdapterName,\n\t\t\trfcName,\n\t\t\t\"shutdown adapter due to too many harmful errors\",\n\t\t)\n\n\t\trfc.ctxCancel()\n\t\treturn\n\t}\n}\n```\ndiagnostics: member-customer-directory/src/internal/pkg/adapter/sap/sap.go\n```go\n\t}\n\n\tconnector, connectorErr := datadog.ExecuteCallWithTracer[*Connector](ctx, rfc.connectorPool.AcquireResource(ctx, true), \"AcquireResource\", rfcName)\n// error: multiple-value rfc.connectorPool.AcquireResource(ctx, true) (value of type (*Connector, error)) in single-value context\n\tif connectorErr != nil {\n\t\treturn nil, connectorErr\n```\n```go\n\t}\n\n\tconnector, connectorErr := datadog.ExecuteCallWithTracer[*Connector](ctx, rfc.connectorPool.AcquireResource(ctx, true), \"AcquireResource\", rfcName)\n// error: cannot use rfcName (variable of type RfcName) as string value in argument to datadog.ExecuteCallWithTracer[*Connector]\n\tif connectorErr != nil {\n\t\treturn nil, connectorErr\n```\n\n\nis a generic wrapping a generic :P\n\nYou're right, there are a couple of issues with the way `ExecuteCallWithTracer` is being used. Let's address them:\n\n1. The `AcquireResource` method returns multiple values, but `ExecuteCallWithTracer` expects a function that returns a single value and an error.\n\n2. The `rfcName` is of type `RfcName`, but `ExecuteCallWithTracer` expects a string.\n\nHere's how we can fix these issues:\n\n```go\nconnector, connectorErr := datadog.ExecuteCallWithTracer(\n    ctx,\n    func() (*Connector, error) {\n        return rfc.connectorPool.AcquireResource(ctx, true)\n    },\n    \"SAP\",\n    string(rfcName),\n)\n```\n\nThis modification does the following:\n\n1. We wrap the `AcquireResource` call in an anonymous function that matches the signature expected by `ExecuteCallWithTracer`.\n\n2. We use \"SAP\" as the `calledSource` parameter to indicate that this is a SAP-related operation.\n\n3. We convert `rfcName` to a string using `string(rfcName)` for the `requestedResource` parameter.\n\nThis should resolve both issues and allow the code to compile and run correctly. The `ExecuteCallWithTracer` function will now properly wrap the `AcquireResource` call with a Datadog span, providing better observability for your SAP operations.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":149}},"image_offsets":[]},{"id":{"replica_id":0,"value":8},"start":4,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":150}},"image_offsets":[]},{"id":{"replica_id":0,"value":83},"start":17153,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":151}},"image_offsets":[]},{"id":{"replica_id":0,"value":103},"start":17189,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":152}},"image_offsets":[]},{"id":{"replica_id":0,"value":104},"start":18398,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":153}},"image_offsets":[]}],"summary":"SAP RFC Adapter implementation with connection pool and error handling","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":4,"end":893},"icon":"Folder","label":"member-customer-directory/src/internal/pkg/datadog"},{"range":{"start":55,"end":892},"icon":"File","label":"member-customer-directory/src/internal/pkg/datadog/datadog.go"},{"range":{"start":894,"end":17151},"icon":"File","label":"member-customer-directory/src/internal/pkg/adapter/sap/sap.go"},{"range":{"start":16385,"end":17151},"icon":"ExclamationTriangle","label":"Diagnostics (member-customer-directory/src/internal/pkg/adapter/sap/sap.go): 2 errors"},{"range":{"start":16460,"end":16805},"icon":"XCircle","label":"multiple-value rfc.connectorPool.AcquireResource(ctx, true) (value of type (*Connector, error)) in single-value context"},{"range":{"start":16806,"end":17150},"icon":"XCircle","label":"cannot use rfcName (variable of type RfcName) as string value in argument to datadog.ExecuteCallWithTracer[*Connector]"}]}